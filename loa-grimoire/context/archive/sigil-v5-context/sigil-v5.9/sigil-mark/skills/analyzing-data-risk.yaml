# Skill: Analyzing Data Risk
# Purpose: Determine physics class from data type in function signature

version: "5.9.0"

skill: analyzing_data_risk
purpose: |
  Determine the correct physics class by analyzing data types in function
  signatures. The button name lies. The data type doesn't.

trigger:
  - Generating action handlers
  - Creating mutation hooks
  - Building interactive components

implementation:
  
  steps:
    1_parse_signature:
      description: "Extract type annotations from function signature"
      examples:
        - input: "(amount: Money) => Promise<void>"
          output: { parameters: [{ name: "amount", type: "Money" }] }
        - input: "(task: Task, assignee: User) => Promise<Task>"
          output: { parameters: [{ name: "task", type: "Task" }, { name: "assignee", type: "User" }], return: "Task" }
          
    2_identify_data_types:
      description: "Map extracted types to constitution categories"
      lookup:
        Money: financial
        Balance: financial
        Transfer: financial
        Withdrawal: financial
        Deposit: financial
        Task: collaborative
        Document: collaborative
        Comment: collaborative
        Preference: local
        Draft: local
        Toggle: local
        
    3_resolve_physics:
      description: "Look up physics in constitution"
      mapping:
        financial: server-tick
        collaborative: crdt
        local: local-first
        
    4_apply_risk_hierarchy:
      description: "If multiple types, use highest-risk physics"
      hierarchy:
        - server-tick  # Highest risk
        - crdt         # Medium risk
        - local-first  # Lowest risk
      rule: "Tier(Physics) = max(risk(Type1), risk(Type2), ...)"

type_extraction:
  
  sources:
    - Function parameters
    - Return type
    - Generic parameters
    - Import context
    
  patterns:
    parameter: "(name: Type)"
    return_type: "=> Promise<Type>"
    generic: "useState<Type>"
    import: "import { Type } from '@/types'"
    
  examples:
    - pattern: "(amount: Money) => Promise<void>"
      extracted: [Money]
      physics: server-tick
      
    - pattern: "(task: Task) => Promise<Task>"
      extracted: [Task]
      physics: crdt
      
    - pattern: "(preference: Preference) => void"
      extracted: [Preference]
      physics: local-first
      
    - pattern: "(amount: Money, task: Task) => Promise<void>"
      extracted: [Money, Task]
      physics: server-tick  # Highest risk wins

output:
  
  schema:
    physics: "server-tick | crdt | local-first"
    requires: ["string"]
    forbidden: ["string"]
    timing:
      duration: number
      easing: string
      
  examples:
    - physics: server-tick
      requires: [simulation, confirmation, explicit-pending]
      forbidden: [useOptimistic, instant-commit]
      timing: { duration: 800, easing: "ease-out" }
      
    - physics: crdt
      requires: [conflict-resolution, background-sync]
      forbidden: [blocking-save]
      timing: { duration: 300, easing: "ease-in-out" }
      
    - physics: local-first
      requires: [useOptimistic, instant-feedback]
      forbidden: [loading-spinner-on-local]
      timing: { duration: 50, easing: "linear" }

error_handling:
  
  unknown_type:
    action: ask-user
    prompt: |
      I couldn't determine the physics for type "{type}".
      
      What kind of data is this?
      1. Financial (money, balances) → server-tick
      2. Collaborative (tasks, documents) → crdt
      3. Local (preferences, UI state) → local-first
      
  multiple_high_risk:
    action: use-highest
    log: true
    message: "Multiple high-risk types detected. Using server-tick."

rationale: |
  Transfer(Money) ≠ Transfer(Task).
  
  The button name "Transfer" could mean either financial transfer (server-tick,
  simulation required) or task reassignment (CRDT, optimistic OK).
  
  Only the data type annotation tells us the true risk level.
  
  This skill ensures the agent never guesses physics from names—it reads
  from the type system, which is the source of truth.
