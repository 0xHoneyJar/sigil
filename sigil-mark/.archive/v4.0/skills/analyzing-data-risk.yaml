# Skill: Analyzing Data Risk
# Purpose: Determine physics class from data type in function signature
# Law: "The button name lies. The data type doesn't."

version: "5.0.0"

skill: analyzing_data_risk
purpose: |
  Determine the correct physics class by analyzing data types in function
  signatures. Transfer(Money) ≠ Transfer(Task). Read the types.

trigger:
  - Generating action handlers
  - Creating mutation hooks
  - Building interactive components
  - Adding @sigil-data-type pragma

# =============================================================================
# TYPE EXTRACTION PATTERNS
# =============================================================================

type_extraction:

  sources:
    - Function parameters
    - Return type
    - Generic parameters
    - Import context

  patterns:
    # Parameter types: (name: Type)
    parameter:
      pattern: '(\w+):\s*(\w+)'
      extract: '$2'

    # Return types: => Promise<Type>
    return_type:
      pattern: '=>\s*Promise<(\w+)>'
      extract: '$1'

    # Return type (non-promise): => Type
    return_simple:
      pattern: '=>\s*(\w+)'
      extract: '$1'

    # Generic parameters: useState<Type>
    generic:
      pattern: '<(\w+)>'
      extract: '$1'

    # Import statements: import { Type } from '@/types'
    import:
      pattern: 'import\s*\{\s*([^}]+)\s*\}\s*from'
      extract: '$1'

  examples:
    - input: "(amount: Money) => Promise<void>"
      extracted: [Money]
      physics: server-tick

    - input: "(task: Task) => Promise<Task>"
      extracted: [Task, Task]
      physics: crdt

    - input: "(preference: Preference) => void"
      extracted: [Preference]
      physics: local-first

    - input: "(amount: Money, task: Task) => Promise<void>"
      extracted: [Money, Task]
      physics: server-tick   # Highest risk wins

# =============================================================================
# CONSTITUTION LOOKUP PROCESS
# =============================================================================

constitution_lookup:

  process:
    1. Parse function signature for types
    2. Look up each type in constitution.yaml data_physics
    3. Map category to physics class
    4. Apply risk hierarchy for multiple types
    5. Return resolved physics with requires/forbidden

  categories:
    financial:
      types: [Money, Balance, Transfer, Withdrawal, Deposit, Payment, Subscription, Invoice, Fee, Stake, Reward, Claim]
      physics: server-tick
      source: "constitution.yaml → data_physics.financial"

    health:
      types: [Health, HP, Hardcore, Permadeath, Lives, Damage, Healing]
      physics: server-tick
      source: "constitution.yaml → data_physics.health"

    collaborative:
      types: [Task, Document, Comment, Thread, Note, Canvas, Whiteboard, Project, Team]
      physics: crdt
      source: "constitution.yaml → data_physics.collaborative"

    local:
      types: [Preference, Draft, Toggle, UI_State, Theme, Layout, Filter, Sort, Bookmark, History]
      physics: local-first
      source: "constitution.yaml → data_physics.local"

  output:
    physics: "server-tick | crdt | local-first"
    requires: ["string[]"]   # From constitution physics profiles
    forbidden: ["string[]"]  # From constitution data_physics
    timing:
      min_ms: number
      recommended_ms: number
      max_ms: number
      feedback_ms: number

# =============================================================================
# RISK HIERARCHY
# =============================================================================

risk_hierarchy:

  rule: "Tier(Physics) = max(risk(Type1), risk(Type2), ...)"

  order:
    - server-tick   # Highest risk (1) — irreversible actions
    - crdt          # Medium risk (2) — collaborative editing
    - local-first   # Lowest risk (3) — user preferences

  examples:
    - types: [Money, Task]
      result: server-tick
      reason: "Money (server-tick) > Task (crdt)"

    - types: [Task, Preference]
      result: crdt
      reason: "Task (crdt) > Preference (local-first)"

    - types: [Preference, Toggle]
      result: local-first
      reason: "Both are local-first"

    - types: [Money, Health]
      result: server-tick
      reason: "Both are server-tick (no change)"

  logging:
    multiple_high_risk: true
    message_template: "Multiple types detected: {types}. Using {physics} (highest risk)."

# =============================================================================
# ERROR HANDLING
# =============================================================================

error_handling:

  unknown_type:
    action: ask-user
    prompt: |
      I couldn't determine the physics for type "{type}".

      What kind of data is this?
      1. Financial (money, balances) → server-tick
      2. Health (HP, lives, damage) → server-tick
      3. Collaborative (tasks, documents) → crdt
      4. Local (preferences, UI state) → local-first

  no_types_found:
    action: use-zone-default
    fallback: "Use zone-based physics resolution"

  import_not_resolved:
    action: log-warning
    message: "Type {type} imported but not in constitution. Treating as unknown."

# =============================================================================
# INTEGRATION WITH useSigilMutation
# =============================================================================

hook_integration:

  options:
    dataType:
      description: "Explicit data type hint for physics resolution"
      type: "string"
      example: "Money"

    dataTypes:
      description: "Multiple data types (uses highest risk)"
      type: "string[]"
      example: ["Money", "Task"]

  resolution_priority:
    1. Explicit dataType/dataTypes option
    2. Extracted from mutation function signature
    3. Zone-based default

  conflict_handling:
    dataType_vs_zone:
      rule: "Data type ALWAYS overrides zone"
      warning: true
      message: "Data type {type} ({physics}) conflicts with zone {zone}. Using data type physics."

  examples:
    - code: |
        useSigilMutation({
          mutation: (amount: Money) => api.transfer(amount),
          dataType: 'Money',  // Explicit hint (optional, extracted from signature)
        });
      result:
        physics: server-tick
        source: "dataType option"

    - code: |
        useSigilMutation({
          mutation: (task: Task) => api.assign(task),
          // No hint needed - extracted from signature
        });
      result:
        physics: crdt
        source: "signature extraction"

# =============================================================================
# IMPLEMENTATION FUNCTIONS
# =============================================================================

implementation:

  functions:
    extractTypesFromSignature:
      description: "Parse TypeScript function signature for types"
      input: "function signature string"
      output: "string[] of type names"

    lookupPhysicsForType:
      description: "Map a type to physics class via constitution"
      input: "type name string"
      output: "{ category, physics, requires, forbidden }"

    resolveHighestRisk:
      description: "Apply risk hierarchy to multiple types"
      input: "string[] of types"
      output: "PhysicsClass"

    integrateWithMutation:
      description: "Enhance useSigilMutation with data type awareness"
      input: "mutation options with dataType"
      output: "resolved physics configuration"

# =============================================================================
# RATIONALE
# =============================================================================

rationale: |
  Transfer(Money) ≠ Transfer(Task).

  The button name "Transfer" could mean either financial transfer (server-tick,
  simulation required) or task reassignment (CRDT, optimistic OK).

  Only the data type annotation tells us the true risk level.

  This skill ensures the agent never guesses physics from names—it reads
  from the type system, which is the source of truth.

  The button name lies. The data type doesn't.
