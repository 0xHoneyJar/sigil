# Sigil Kernel: Sync Primitives
# IMMUTABLE after /codify --lock
# These define how data synchronizes between client and server.
# The sync strategy determines UI behavior—optimistic vs. confirmed.

version: "1.0"
locked: false
locked_at: null
locked_by: null

# ═══════════════════════════════════════════════════════════════════════════════
# SYNC STRATEGIES
# Each strategy has different trust models and UI implications
# ═══════════════════════════════════════════════════════════════════════════════

strategies:
  # ─────────────────────────────────────────────────────────────────────────────
  # CRDT: Collaborative Real-Time Data Types
  # For content that multiple users edit simultaneously
  # ─────────────────────────────────────────────────────────────────────────────
  crdt:
    id: "sync.crdt"
    name: "CRDT"
    full_name: "Conflict-free Replicated Data Types"
    description: "Collaborative editing with automatic merge"

    use_cases:
      - "Document editing"
      - "Chat messages"
      - "Comments and annotations"
      - "Rich text content"
      - "Collaborative whiteboards"

    ui_behavior:
      optimistic: true
      show_presence: true
      show_cursors: true
      pending_indicator: "subtle"  # Small dot or none
      conflict_resolution: "automatic"

    trust_model: "eventually_consistent"

    hook_template: |
      export function useCRDTText(docId: string) {
        const [doc, setDoc] = useState<Y.Doc | null>(null);
        const [text, setText] = useState('');
        const [peers, setPeers] = useState<Peer[]>([]);

        useEffect(() => {
          const ydoc = new Y.Doc();
          const ytext = ydoc.getText('content');

          // Observe changes
          ytext.observe(() => setText(ytext.toString()));

          // Connect to provider
          const provider = new WebrtcProvider(docId, ydoc);
          provider.awareness.on('change', () => {
            setPeers(Array.from(provider.awareness.getStates().values()));
          });

          setDoc(ydoc);
          return () => provider.destroy();
        }, [docId]);

        const insert = (index: number, content: string) => {
          doc?.getText('content').insert(index, content);
        };

        return { text, peers, insert };
      }

    references:
      - "Google Docs"
      - "Figma"
      - "Notion"
      - "Linear comments"

  # ─────────────────────────────────────────────────────────────────────────────
  # LWW: Last-Write-Wins
  # For state that can be safely overwritten
  # ─────────────────────────────────────────────────────────────────────────────
  lww:
    id: "sync.lww"
    name: "LWW"
    full_name: "Last-Write-Wins"
    description: "Latest timestamp wins, instant local update"

    use_cases:
      - "Object positions"
      - "Toggle states"
      - "Selections"
      - "User preferences"
      - "UI state"
      - "Non-critical settings"

    ui_behavior:
      optimistic: true
      show_presence: false
      pending_indicator: "none"
      conflict_resolution: "timestamp"

    trust_model: "local_first"

    hook_template: |
      export function useLocalFirst<T>(
        key: string,
        initial: T,
        persist: boolean = true
      ) {
        const [value, setValue] = useState<T>(() => {
          if (persist && typeof window !== 'undefined') {
            const stored = localStorage.getItem(key);
            return stored ? JSON.parse(stored) : initial;
          }
          return initial;
        });

        const [isSyncing, setIsSyncing] = useState(false);

        const update = useCallback(async (newValue: T) => {
          // Instant local update
          setValue(newValue);

          if (persist) {
            localStorage.setItem(key, JSON.stringify(newValue));
          }

          // Background sync (non-blocking)
          setIsSyncing(true);
          try {
            await api.patch(`/state/${key}`, {
              value: newValue,
              timestamp: Date.now()
            });
          } finally {
            setIsSyncing(false);
          }
        }, [key, persist]);

        return { value, update, isSyncing };
      }

    references:
      - "Local-first software"
      - "Offline-capable apps"
      - "Settings panels"

  # ─────────────────────────────────────────────────────────────────────────────
  # SERVER-TICK: Server-Authoritative
  # For high-stakes data that MUST be confirmed before UI updates
  # ─────────────────────────────────────────────────────────────────────────────
  server_tick:
    id: "sync.server_tick"
    name: "Server-Tick"
    full_name: "Server-Authoritative Tick"
    description: "Server is single source of truth. NEVER optimistic."

    # CRITICAL: This is for data where wrong UI = security/trust violation
    use_cases:
      - "Money / Currency / Balance"
      - "Inventory / Assets"
      - "Health / Combat stats"
      - "Trades / Transactions"
      - "Withdrawals / Deposits"
      - "Claims / Minting"
      - "Voting results"
      - "Auction bids"

    ui_behavior:
      optimistic: false  # CRITICAL: NEVER optimistic
      show_presence: false
      pending_indicator: "prominent"
      confirmation_required: true
      confirmation_style: "xp_drop"  # OSRS-style rising text

    trust_model: "server_authoritative"
    tick_rate_ms: 600  # OSRS tick rate

    # UI MUST show these states
    required_states:
      - "idle"
      - "pending"       # Request sent, waiting for server
      - "confirming"    # Server processing
      - "success"       # Server confirmed
      - "error"         # Server rejected

    hook_template: |
      export function useServerTick<T, R>(
        action: (payload: T) => Promise<R>
      ) {
        const [state, setState] = useState<
          'idle' | 'pending' | 'confirming' | 'success' | 'error'
        >('idle');
        const [error, setError] = useState<Error | null>(null);
        const [result, setResult] = useState<R | null>(null);

        const execute = useCallback(async (payload: T) => {
          // NEVER update optimistically
          setState('pending');
          setError(null);

          try {
            setState('confirming');
            const response = await action(payload);

            // Only update AFTER server confirms
            setResult(response);
            setState('success');

            // Auto-reset after confirmation animation
            setTimeout(() => setState('idle'), 2000);

            return response;
          } catch (err) {
            setError(err as Error);
            setState('error');
            throw err;
          }
        }, [action]);

        return {
          execute,
          state,
          isPending: state === 'pending' || state === 'confirming',
          isSuccess: state === 'success',
          isError: state === 'error',
          error,
          result,
        };
      }

    # Component behavior requirements
    component_requirements:
      button:
        - "MUST be disabled while pending"
        - "MUST show loading indicator"
        - "MUST NOT change value until server confirms"
        - "MUST show success animation (xp_drop)"
        - "MUST show error state clearly"

      display:
        - "MUST show stale indicator if pending"
        - "MUST NOT show optimistic value"
        - "MUST animate value change on confirmation"

    references:
      - "Old School RuneScape (0.6s tick)"
      - "Bank transactions"
      - "Cryptocurrency transfers"
      - "DeFi swaps"

  # ─────────────────────────────────────────────────────────────────────────────
  # LOCAL-ONLY: No sync
  # For ephemeral UI state
  # ─────────────────────────────────────────────────────────────────────────────
  local_only:
    id: "sync.local_only"
    name: "Local-Only"
    full_name: "Local-Only State"
    description: "No server sync, ephemeral state"

    use_cases:
      - "Modal open/close"
      - "Dropdown state"
      - "Hover state"
      - "Animation state"
      - "Form validation state"
      - "Temporary selections"

    ui_behavior:
      optimistic: true  # Always instant
      show_presence: false
      pending_indicator: "none"

    trust_model: "local"

    hook_template: |
      // Just use useState
      const [isOpen, setIsOpen] = useState(false);

    references:
      - "React useState"
      - "UI toggles"

# ═══════════════════════════════════════════════════════════════════════════════
# DETECTION RULES
# Keywords that signal which sync strategy to use
# ═══════════════════════════════════════════════════════════════════════════════

detection:
  # Server-tick signals (highest priority - safety critical)
  server_tick_signals:
    keywords:
      - "trade"
      - "transfer"
      - "send"
      - "buy"
      - "sell"
      - "money"
      - "balance"
      - "withdraw"
      - "deposit"
      - "claim"
      - "mint"
      - "burn"
      - "swap"
      - "stake"
      - "unstake"
      - "attack"
      - "damage"
      - "health"
      - "inventory"
      - "equip"
      - "unequip"
      - "vote"
      - "bid"
      - "auction"

    patterns:
      - "**/features/checkout/**"
      - "**/features/trade/**"
      - "**/features/wallet/**"
      - "**/features/claim/**"
      - "**/features/combat/**"

  # CRDT signals
  crdt_signals:
    keywords:
      - "edit"
      - "type"
      - "write"
      - "comment"
      - "message"
      - "document"
      - "note"
      - "draft"
      - "collaborate"
      - "whiteboard"

    patterns:
      - "**/features/editor/**"
      - "**/features/docs/**"
      - "**/features/chat/**"
      - "**/features/comments/**"

  # LWW signals
  lww_signals:
    keywords:
      - "move"
      - "drag"
      - "toggle"
      - "select"
      - "preference"
      - "setting"
      - "theme"
      - "sort"
      - "filter"
      - "collapse"
      - "expand"

    patterns:
      - "**/features/settings/**"
      - "**/features/preferences/**"
      - "**/components/ui/**"

# ═══════════════════════════════════════════════════════════════════════════════
# EXPLICIT MAPPINGS
# Override detection with explicit path → strategy mappings
# ═══════════════════════════════════════════════════════════════════════════════

explicit_mappings:
  # These override detection
  # Format: "data.path" → strategy

  # Always server-tick (never optimistic)
  "player.balance": "server_tick"
  "player.inventory": "server_tick"
  "player.health": "server_tick"
  "player.equipment": "server_tick"
  "trade.*": "server_tick"
  "transaction.*": "server_tick"
  "wallet.balance": "server_tick"

  # Always CRDT (collaborative)
  "document.content": "crdt"
  "comment.body": "crdt"
  "note.content": "crdt"

  # Always LWW (local-first)
  "user.preferences": "lww"
  "user.settings": "lww"
  "ui.layout": "lww"
  "ui.theme": "lww"

  # Always local-only (ephemeral)
  "ui.modal.*": "local_only"
  "ui.dropdown.*": "local_only"
  "form.validation.*": "local_only"
